<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Growing Path">
<meta property="og:type" content="website">
<meta property="og:title" content="Joyce&#39; Blog">
<meta property="og:url" content="http://yoursite.com/page/21/index.html">
<meta property="og:site_name" content="Joyce&#39; Blog">
<meta property="og:description" content="Growing Path">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joyce&#39; Blog">
<meta name="twitter:description" content="Growing Path">

<link rel="canonical" href="http://yoursite.com/page/21/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Joyce' Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Joyce' Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/智能商务及大数据综合实践安排/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="Joyce">
      <meta itemprop="description" content="Growing Path">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joyce' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/24/智能商务及大数据综合实践安排/" class="post-title-link" itemprop="url">智能商务及大数据综合实践安排</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-06-24 10:05:55 / 修改时间：18:04:39" itemprop="dateCreated datePublished" datetime="2019-06-24T10:05:55+08:00">2019-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>淘聘网</p>
<p>王炜</p>
<p>课程目标：一个数据平台</p>
<ol>
<li>python编程 爬取数据</li>
<li>模拟Oracle BI 软件，系统原型搭建，建模</li>
</ol>
<p>课程考核：</p>
<p>提供数据或自己收集，做分析。</p>
<p>数据分析：</p>
<ol>
<li>BIEE——oracle企业版</li>
<li>最基本的方式：Excel</li>
<li>Python</li>
</ol>
<p>IOE（IBM的小型机、Oracle数据库、EMC存储设备）</p>
<p>BATJ（百度、阿里巴巴、腾讯、京东）</p>
<p>FLAG（Facebook，LinkedIn，Amazon，Google）</p>
<p>建模：物理，逻辑，应用</p>
<p>实训报告：实训目的、实训内容、调试程序的步骤、实验过程总结、总结</p>
<hr>
<p>练习unix和linux环境</p>
<p>IAAS，PAAS(platform)，SAAS</p>
<p>信息系统架构的演变：数据服务器，应用服务器，Web服务器，客户端</p>
<p>BI系统，ERP系统，CRM管理系统</p>
<p>数据化：OLTP(处理)与OLAP(分析)</p>
<p>大数据4v：数据量，速度，多样性，价值</p>
<p>中间件 商务智能应用</p>
<p>看文档和教程Tutorial 建模：11g Admininstraion 第一行</p>
<p>数据展现分析和仪表盘（new）第二条</p>
<p>数据孤岛 oracle主页</p>
<p>产品-业务分析</p>
<p>305 PDF</p>
<hr>
<p>通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/15/计组复习笔记（五）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="Joyce">
      <meta itemprop="description" content="Growing Path">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joyce' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/15/计组复习笔记（五）/" class="post-title-link" itemprop="url">计组复习笔记（五）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-15 20:33:35" itemprop="dateCreated datePublished" datetime="2019-06-15T20:33:35+08:00">2019-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-06-16 22:38:15" itemprop="dateModified" datetime="2019-06-16T22:38:15+08:00">2019-06-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>冯诺依曼计算机工作方式的基本特点：按地址访问并顺序执行指令</p>
<p>指令寄存器（Instruction Register，IR）用来保存当前正在执行的一条指令。程序计数器（Program Counter，PC）用来指出下一条指令在主存储器中的地址。</p>
<p>[例题]一个四路组相联的cache共有64块,主存共有8192块,每块32字,则主存地址中字块标记,组地址,块内地址的位数分别是：<font color="red">9,4,5</font></p>
<p>从题中可看出：<br>每块32字所以块内地址为5位,2的5次方等于32,.<br>64/4=16组,2的4次方等于16,所以组地址为4位,（如果是直接相连的话,那么就是2的6次方等于64,块地址就为6位了,但是这里是4路组相连,所以是组地址,而不是块地址）<br>然后主存一共有8192*32个字,取LOG,也就是18位,<br>所以字块标记为18-5-4=9位.<br>主存字块标记 组地址 块内地址<br>9位 4位 5位        <font color="red">不要总认为地址就是32位呀！！！</font></p>
<p>浮点乘法判溢出的时刻是：阶码求和之后尾数相乘并规格化之后</p>
<p>RISC有乘除指令和浮点运算指令。RISC的主要目的是减少指令数。</p>
<p>在微程序处理器中，N种微操作，控制字段要设置的位数是$log_2N向上取整+1$    <font color="red">考虑N=1的情况</font></p>
<p>在规格化数表示中，保持其他方面不变，将阶码部分的移码改为补码表示，则数的表示范围不变。</p>
<p>认真读题——“每次取<font color="red">一个字节</font>PC自动加1”，“两个字节”</p>
<p>寄存器间接寻址方式：寄存器内存放的是操作数的地址，而不是操作数本身，即操作数是通过寄存器间接得到的。操作数处于内存单元中。</p>
<p>寄存器相对寻址方式：操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)或变址寄存器(SI、DI)的内容和指令中的8位/16位偏移量之和。</p>
<p>为提高存储器存取效率，通常将同一文件存放在不同面的同一磁道上。</p>
<p>正数的<strong>反码</strong>等于其原<strong>码</strong>，而负数的<strong>反码</strong>则可以通过保留其<strong>符号位</strong>，将原<strong>码</strong>的数值<strong>位</strong>取<strong>反</strong>得到。</p>
<p>硬件向量法， 就是通过向量地址来寻找设备的中断服务程序入口地址，而且向量地址是由硬件电路产生的。</p>
<p><strong>题目3.47</strong> 下面C代码实现了一个4阶FIR滤波器，输入为数组 sig_in 。设所有数组元素为16位定点数。假设你要面向 一个具有SIMD指令集且有128位寄存器的处理器，用汇编语言优化该代码。在不知指令细节的情况下，简要介绍一 下如何实现该代码，最大限度用字并行操作，并使寄存器和存储器间数据传送量最少。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">3</span>;i&lt;<span class="number">128</span>;i++)    sig_out[i] = sig_in[i<span class="number">-3</span>]*f[<span class="number">0</span>]+sig_in[i<span class="number">-2</span>]*f[<span class="number">1</span>]+sig_in[i<span class="number">-1</span>]*f[<span class="number">2</span>]+sig_in[i]*f[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">F=[f[<span class="number">3</span>],f[<span class="number">2</span>],f[<span class="number">1</span>],f[<span class="number">0</span>],f[<span class="number">3</span>],f[<span class="number">2</span>],f[<span class="number">1</span>],f[<span class="number">0</span>]]</span><br><span class="line">B=[sig_in[<span class="number">7</span>],sig_in[<span class="number">6</span>],...,sig_in[<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">    A=[sig_in[i*<span class="number">8</span>+<span class="number">7</span>],...,sig_in[i*<span class="number">8</span>+<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">0</span></span><br><span class="line">        <span class="comment">// 为了保证i=0时不会数组下界溢出</span></span><br><span class="line">        B=[sig_in(i<span class="number">-1</span>)*<span class="number">8</span>+<span class="number">7</span>,...,sig_in[(i<span class="number">-1</span>)*<span class="number">8</span>+<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        C=A*F</span><br><span class="line">    	sig_out[i*<span class="number">8</span>+j+<span class="number">4</span>],sig_out[i*<span class="number">8</span>+j]=C[<span class="number">127</span>:<span class="number">64</span>],C[<span class="number">63</span>:<span class="number">0</span>]</span><br><span class="line">        A=A&lt;&lt;<span class="number">16</span>*<span class="number">1b</span>it</span><br><span class="line">        E=B&gt;&gt;<span class="number">16</span>*<span class="number">7b</span>it</span><br><span class="line">        A=A OR E</span><br><span class="line">        B=B&lt;&lt;<span class="number">16</span>*<span class="number">1b</span>it<span class="comment">// 为A提供持续最右侧sig_in[]</span></span><br></pre></td></tr></table></figure>
<p>==作业5.7.1==：j的初始值应为3，条件是≥0，–j；另外在i=0时要将B设为全0</p>
<p><strong>吞吐率</strong>：单位时间内流水线所完成的任务数量或输出结果的数量</p>
<p><strong>效率</strong></p>
<p><strong>加速比</strong></p>
<font color="red">Cache的字块内地址</font> VS <font color="blue">Cache的字块地址</font>

<hr>
<p>正数的补码反码和原码是一样的。原码和补码之间的互换方式都是除符号位之外，按位取反，末位加1</p>
<p><img src="//yoursite.com/2019/06/15/计组复习笔记（五）/blog\source\_posts\sql\28.PNG" alt="28"></p>
<p>推断 跳转指令的转移地址 (PC+4)+(OFFSET)*4</p>
<p>条件转移指令的相对位移量（16位，用补码表示）的范围为：$-2^{15}至 +(2^{15}-1)$（是相对于转移指令的下调指令而言）。及最多往前调到第32768条指令(131072个单元)，最多往后跳到第32767条指令(131068个单元)。</p>
<p>无条件转移指令的目标地址范围为：0~$2^{26}-1$（相对于下条指令），即，最近就跳到下条指令，最远跳到后面的$2^{26}-1$条指令</p>
<p>注意计算时int+short时的符号扩展</p>
<p>对阶操作不会引起阶码的溢出，因为是小阶向大阶对齐；右规可能造成阶码上溢；左规可能造成阶码下溢；尾数舍入过程，阶码加 1 而可能上溢；尾数溢出时结果不一定溢出。</p>
<p>某计算机的Cache共有32块，采用8路组相联映射方式。每个主存块大小为16字节，按字节编址。主存133号单元所在主存块应装入到的Cache组号是 <font color="red">0</font></p>
<font color="red">汇编指令与流水线结合，如何修改给定的汇编代码，使得总指令周期最短？涉及到冒险的知识？</font>

<font color="red">Cache和虚存，已知Cache和内存表，给出访问要求，列出命中情况</font>

<p><img src="//yoursite.com/2019/06/15/计组复习笔记（五）/blog\source\_posts\sql\29.PNG" alt="29"></p>
<p><strong>(3)</strong></p>
<p>在1000条指令过程中共访问存储器1500次，其中1410次仅访问一级Cache，54次访问至二级Cache，36次访问主存储器，要求它们的平均值：</p>
<p>$(1410<em>1+54</em>10+36*100)/1500=3.7$</p>
<p><strong>(4)</strong></p>
<p>访存这一个动作，理论上只需要一个周期，一条指令有1.5次访存，也就是1.5个周期。而实际用了3.7个周期，多出来的2.2个时钟周期即为访问存储器导致的停顿。</p>
<p><strong>(5)</strong></p>
<p>每条指令访存1.5次，每次访存需要3.7个周期，只考虑访问存储器的话，CPI=1.5*3.7=5.55</p>
<p><img src="//yoursite.com/2019/06/15/计组复习笔记（五）/Users\asus\AppData\Roaming\Typora\typora-user-images\1560692574537.png" alt="1560692574537"></p>
<hr>
<font color="pink">今天是很美好的一天，因为和爸爸说了“父亲节快乐！”</font>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/15/计组复习笔记（四）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="Joyce">
      <meta itemprop="description" content="Growing Path">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joyce' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/15/计组复习笔记（四）/" class="post-title-link" itemprop="url">计组复习笔记（四）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-06-15 08:20:47 / 修改时间：15:21:38" itemprop="dateCreated datePublished" datetime="2019-06-15T08:20:47+08:00">2019-06-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="存储器层次"><a href="#存储器层次" class="headerlink" title="存储器层次"></a>存储器层次</h1><p><strong>局部性原理</strong></p>
<p>存储信息交换的最小单元称为块（或行）</p>
<p>缺失代价：将相应的块从低层存储器替换到高层存储器所需的时间，包括访问块、将数据逐层传输、将数据插入发生缺失的曾和将信息传送给请求者的时间。</p>
<h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p>现代DRAM以bank存储块方式组织。每个bank由多个行组成，发送一条Pre(预充电)命令能够打开或关闭一个bank。bank可同时进行读或写操作，“地址交叉”的轮转访问方式。多体（bank）并行</p>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>磁道、扇区、柱面</p>
<p>扇区：512~4096个字节，扇区号、一个间隙、包含该扇区纠错码的信息、一个间隙、下一个扇区的扇区号</p>
<p>寻道、旋转延时（平均延时通常是磁盘转动一周时间的一半）、</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>直接映射：(Block address) modulo (#Blocks in cache)</p>
<p>标记（地址的高位，即 没有用来检索cache的那些位）、有效位</p>
<p><img src="//yoursite.com/2019/06/15/计组复习笔记（四）/blog\source\_posts\sql\21.PNG" alt="21"></p>
<p>Cache大小固定，块的大小与数量的折中</p>
<h4 id="Cache缺失处理"><a href="#Cache缺失处理" class="headerlink" title="Cache缺失处理"></a>Cache缺失处理</h4><p>指令Cache缺失：流水线阻塞，PC-4的值送到存储器中，主存进行读操作，数据写入Cache，并将地址的高位（ALU中得到）写入标记域，设置有效位。重新取指。</p>
<h5 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h5><p>写缓冲，满了就写</p>
<p>策略：写分配，数据块从主存中取回，并且在该块中的恰当区域重写数据（比如循环中的++i）。或直接改（变量初始化）不写入Cache。</p>
<h5 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h5><p>Cache被换才写 (dirty)，可使用一个写缓冲来保存数据</p>
<h4 id="计算Cache性能"><a href="#计算Cache性能" class="headerlink" title="计算Cache性能"></a>计算Cache性能</h4><p>Given：</p>
<ol>
<li>I-cache miss rate = 2%</li>
<li>D-cache miss rate = 4%</li>
<li>Miss penalty = 100 cycles</li>
<li>Base CPI (ideal cache) = 2</li>
<li>Load &amp; stores are 36% of instructions</li>
</ol>
<p>Miss cycles per instruction：</p>
<ol>
<li>I-cache: 0.02 × 100 = 2</li>
<li>D-cache: 0.36 × 0.04 × 100 = 1.44</li>
</ol>
<p>Actual CPI = 2 + 2 + 1.44 = 5.44</p>
<p>Ideal CPU is 5.44/2 =2.72 times faster</p>
<p><strong>Average memory access time (AMAT)</strong>    AMAT = Hit time + Miss rate × Miss penalty</p>
<h4 id="Cache相联"><a href="#Cache相联" class="headerlink" title="Cache相联"></a>Cache相联</h4><p>全相联</p>
<p>组相连</p>
<p><img src="//yoursite.com/2019/06/15/计组复习笔记（四）/blog\source\_posts\sql\22.PNG" alt="22"></p>
<h5 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h5><p>组相连：LRU或随机</p>
<h5 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h5><p>计算CPI</p>
<p>一、二级Cache的任务不同（命中时间、缺失率）</p>
<p>通过分块进行软件优化—==分块算法操作子矩阵（我不会啊）==</p>
<h3 id="可信存储器层次"><a href="#可信存储器层次" class="headerlink" title="可信存储器层次"></a>可信存储器层次</h3><p>平均无故障时间mean time to failure (MTTF)</p>
<p>平均维修时间mean time to repair (MTTR)</p>
<p>失效间隔平均时间Mean time between failures (MTBF) =MTTF+MTTR</p>
<p>可用性Availability = MTTF / (MTTF + MTTR)</p>
<p>增加MTTF –&gt; 故障避免技术，故障容忍技术，故障预报技术</p>
<p>减少MTTR –&gt; 采用故障检测、诊断和修复的工具</p>
<h4 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a><font color="red">汉明码</font></h4><p>检错</p>
<p>汉明纠错码：</p>
<p>所有编号为2的整数次幂的位标记为奇偶校验位，剩余为数据位</p>
<p>校验码1检查1,3,5,7…(二进制最右1位均为1)</p>
<p>校验码2检查2,3,6,7…(二进制最右2位均为1)</p>
<p>校验码4检查4,5,6,7…(二进制最右3位均为1)</p>
<p>……</p>
<p>计算SEC需要的位数：$2^p≥log(p+d+1)$，p个校验位，d个数据位</p>
<h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p>似乎不作为考试内容</p>
<h3 id="虚存"><a href="#虚存" class="headerlink" title="虚存"></a>虚存</h3><p>页、缺页</p>
<p>虚页号 — 物理页号</p>
<p>页偏移</p>
<p><img src="//yoursite.com/2019/06/15/计组复习笔记（四）/blog\source\_posts\sql\23.PNG" alt="23"></p>
<p>降低缺页率：使用全相连、先进的替换算法、写回机制</p>
<h4 id="页的存放和查找"><a href="#页的存放和查找" class="headerlink" title="页的存放和查找"></a>页的存放和查找</h4><p>页表PTE：存放在存储器中，使用一个索引存储器的表来定位页。硬件包含一个指向页表首地址的寄存器。</p>
<p><img src="//yoursite.com/2019/06/15/计组复习笔记（四）/blog\source\_posts\sql\24.PNG" alt="24"></p>
<p>每个页表项使用1位有效位、引用位（也叫使用位，周期性清零）、脏位。页表包含了每个可能的虚拟页的映射，因此不需要标记位。索引是用来访问页表的，由整个块地址即虚页号组成。主存中的页和磁盘中的页大小相等。</p>
<h4 id="快表TLB"><a href="#快表TLB" class="headerlink" title="快表TLB"></a>快表TLB</h4><p>由于页表存放在主存中，程序每次至少两次访存：获得物理地址+获得数据。</p>
<p>利用页表的访问局部性，特殊的地址转换—&gt;快表（地址变换高速缓存）</p>
<p>TLB每次装单条，是用全相连，需要回写。每个标记项存放虚页号的一部分，每个数据项中存放物理页号。TLB有标记域！</p>
<p><img src="//yoursite.com/2019/06/15/计组复习笔记（四）/blog\source\_posts\sql\25.PNG" alt="25"></p>
<p><strong>TLB缺失</strong>：</p>
<p>如果不是缺页，处理器将页表中的变换装载到TLB中并重新访问</p>
<p>如果是缺页，操作系统更新页表</p>
<p><strong>TLB和Cache实现从虚拟地址导数据项的转换</strong></p>
<p>TLB在Cache的前面，物理页号与页偏移共同形成访问Cache的索引</p>
<p><img src="//yoursite.com/2019/06/15/计组复习笔记（四）/blog\source\_posts\sql\26.PNG" alt="26"></p>
<p>图中标记和数据RAM是分开的，用Cache索引和块偏移寻址长而窄的数据RAM，无需使用16:1的多路选择器</p>
<p>Cache命中只可能发生在TLB命中之后</p>
<h4 id="缺失的种类"><a href="#缺失的种类" class="headerlink" title="缺失的种类"></a>缺失的种类</h4><p>强制缺失</p>
<p>容量缺失：在全相连时不可能容纳所有请求的块</p>
<p>冲突缺失（碰撞缺失）在全相连中不存在。</p>
<table>
<thead>
<tr>
<th>Design   change</th>
<th>Effect   on miss rate</th>
<th>Negative   performance effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Increase   cache size</td>
<td>Decrease   capacity misses</td>
<td>May   increase access time</td>
</tr>
<tr>
<td>Increase   associativity</td>
<td>Decrease   conflict misses</td>
<td>May   increase access time</td>
</tr>
<tr>
<td>Increase   block size</td>
<td>Decrease   compulsory misses</td>
<td>Increases   miss penalty. For very large block size, may increase miss rate due to   pollution.</td>
</tr>
</tbody>
</table>
<h4 id="有限状态机控制Cache"><a href="#有限状态机控制Cache" class="headerlink" title="有限状态机控制Cache"></a>有限状态机控制Cache</h4><p><img src="//yoursite.com/2019/06/15/计组复习笔记（四）/blog\source\_posts\sql\27.PNG" alt="27"></p>
<font color="red">注意区别字地址和字节地址</font>

<p>不应用存储器平均访问时间来评估乱序处理器的存储器层次结构。—- 模拟乱序处理器和存储器层次结构</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/13/数据库练习题笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="Joyce">
      <meta itemprop="description" content="Growing Path">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joyce' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/13/数据库练习题笔记/" class="post-title-link" itemprop="url">数据库练习题笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-13 14:54:03" itemprop="dateCreated datePublished" datetime="2019-06-13T14:54:03+08:00">2019-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-06-14 08:52:51" itemprop="dateModified" datetime="2019-06-14T08:52:51+08:00">2019-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注意多个属性的外键</p>
<p>已知关系模式 R(a,b)和 S(b,c):</p>
<p>Q1: SELECT a FROM R,S WHERE R.b=S.b;</p>
<p>Q2: SELECT a FROM R WHERE b IN (SELECT b FROM S);</p>
<p>(A)Q1和Q2产生的结果一样; </p>
<p>(B)Q1的结果总是包含Q2的结果;</p>
<p>(C) Q2的结果总是包含Q1的结果; </p>
<p>(D) Q1和Q2产生不同的结果;</p>
<font color="red">B，因为Q1会有重复的元组</font>



<p>如果违反3NF，会出现插入、删除、更新异常；满足了3NF，可能还是会出现插入、删除、更新异常</p>
<p>对日志进行recovery之后，在日志上、追加&lt;Ti, abort&gt; </p>
<p>逻辑查询计划和物理查询计划都有多个，只是最后选最优的执行</p>
<p>考试的第一题 根据ER写表，按上课教的方法画出来符合3NF要求</p>
<p>只有读操作的话，加读锁</p>
<p>触发器、存储过程、更新锁都不考</p>
<p>没有函数依赖的表，肯定是BCNF</p>
<p>解析–关系代数的树–逻辑层优化–估计节点大小、多种查询–物理计划–挑最好的执行</p>
<p>统计的中间结果存起来</p>
<p>物理模式，逻辑模式，用户模式</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/12/算法复习笔记（六）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="Joyce">
      <meta itemprop="description" content="Growing Path">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joyce' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/12/算法复习笔记（六）/" class="post-title-link" itemprop="url">算法复习笔记（六）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-06-12 09:41:27 / 修改时间：10:58:47" itemprop="dateCreated datePublished" datetime="2019-06-12T09:41:27+08:00">2019-06-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="判断集合S中是否存在有两个其和等于x的元素"><a href="#判断集合S中是否存在有两个其和等于x的元素" class="headerlink" title="判断集合S中是否存在有两个其和等于x的元素"></a>判断集合S中是否存在有两个其和等于x的元素</h4><p>将S排序，借用辅助数组$S^{‘}=x-S$，合并$S^{‘}$和S</p>
<h4 id="dutch-national-flag-problem"><a href="#dutch-national-flag-problem" class="headerlink" title="dutch national flag problem"></a>dutch national flag problem</h4><p>红色球要全部在数组的左侧，白色球全部在中间，蓝色球全部在右侧，在遍历一次所有元素的情况下完成排序。</p>
<h4 id="maximum-sub-segment-sum"><a href="#maximum-sub-segment-sum" class="headerlink" title="maximum-sub-segment-sum"></a>maximum-sub-segment-sum</h4><p>针对每一个元素，有两个部分需要关注：① “过去部分” pre_sum；② “当前部分”nums[i]本身。有两种选择，① 加上pre_sum，本身融入到子串当中；② 以“当前部分”为子串起始位置，完全抛弃“过去部分”。</p>
<h4 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a>最大子矩阵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0, -2, -7,  0, 3</span><br><span class="line">9,  2, -6,  2, 5</span><br><span class="line">-4, 1, -4,  1, 6</span><br><span class="line">-1, 8,  0, -2, 2</span><br></pre></td></tr></table></figure>
<p>借鉴或者转为最大子序列，需要加一个辅助矩阵：全部子列和（totalColSum）</p>
<p>有了该辅助矩阵，我们就可以轻松求出指定列的子列和：</p>
<p>0, -2, -7, 0, 3<br>9, 0, -13, 2, 8<br>5, 1, -17, 3, 14<br>4, 9, -17, 1, 16</p>
<ul>
<li>假如当前的子矩阵是{0,1}行，可直接得到子列和为9,0,-13,2,8</li>
<li>假如当前的子矩阵是{1,2}行，可通过totalColSum的第2行减去第0行的数据而得5,3,-4,3,11</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/10/计组复习笔记（三）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="Joyce">
      <meta itemprop="description" content="Growing Path">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joyce' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/10/计组复习笔记（三）/" class="post-title-link" itemprop="url">计组复习笔记（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-10 20:12:51" itemprop="dateCreated datePublished" datetime="2019-06-10T20:12:51+08:00">2019-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-06-17 11:18:50" itemprop="dateModified" datetime="2019-06-17T11:18:50+08:00">2019-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h1><p><strong>ALU used for</strong></p>
<ol>
<li>Load/Store: F = add</li>
<li>Branch: F = subtract</li>
<li>R-type: F depends on funct field</li>
</ol>
<p><img src="//yoursite.com/2019/06/10/计组复习笔记（三）/blog\source\_posts\sql\11.PNG" alt="11"></p>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>提高吞吐率，并未减少单一指令的执行时间（延迟latency）</p>
<p><strong>吞吐率</strong> TP：单位时间内流水线所完成的任务数量或输出结果的数量</p>
<p>$TP=n/T_k=n/[(n+k-1)*δt]$，n为任务数，$T_k$是处理完n个任务所用的时间</p>
<p><strong>加速比</strong> S：完成同样一批任务，顺序执行所用的时间与使用流水线所用的时间之比</p>
<p>$S=T_0/T_k$</p>
<p><strong>效率</strong> E：流水线上的设备利用率，即时空图上，N个任务占用的时空区与K个流水段占用的总时空区之比。由于流水线有建立时间和排空时间，各段并不总是满负荷工作的。</p>
<p>E=n个任务占用的时空区/k个流水段占用的时空区=n/(n-k+1)</p>
<p>在时空图上体现为执行所有指令需要的时间和实际用的时间，多余的时间由建立时间和排空时间造成</p>
<p>5个处理步骤：IF，ID，EX，MEM，WB</p>
<h3 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h3><h4 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h4><p>硬件占用：内存读写—IM，DM分开</p>
<h4 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h4><p>拿错数据</p>
<ol>
<li>前推/旁路</li>
<li>重新安排代码避免阻塞</li>
</ol>
<p>C code for A = B + E; C = B + F</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lw	</span>$<span class="built_in">t1</span>, <span class="number">0</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">lw	</span>$<span class="built_in">t2</span>, <span class="number">4</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">add	</span>$<span class="built_in">t3</span>, $<span class="built_in">t1</span>, $<span class="built_in">t2</span></span><br><span class="line"><span class="keyword">sw	</span>$<span class="built_in">t3</span>, <span class="number">12</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">lw	</span>$<span class="built_in">t4</span>, <span class="number">8</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">add	</span>$<span class="built_in">t5</span>, $<span class="built_in">t1</span>, $<span class="built_in">t4</span></span><br><span class="line"><span class="keyword">sw	</span>$<span class="built_in">t5</span>, <span class="number">16</span>($<span class="built_in">t0</span>)</span><br></pre></td></tr></table></figure>
<p>重新安排代码:</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lw	</span>$<span class="built_in">t1</span>, <span class="number">0</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">lw	</span>$<span class="built_in">t2</span>, <span class="number">4</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">lw	</span>$<span class="built_in">t4</span>, <span class="number">8</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">add	</span>$<span class="built_in">t3</span>, $<span class="built_in">t1</span>, $<span class="built_in">t2</span></span><br><span class="line"><span class="keyword">sw	</span>$<span class="built_in">t3</span>, <span class="number">12</span>($<span class="built_in">t0</span>)</span><br><span class="line"><span class="keyword">add	</span>$<span class="built_in">t5</span>, $<span class="built_in">t1</span>, $<span class="built_in">t4</span></span><br><span class="line"><span class="keyword">sw	</span>$<span class="built_in">t5</span>, <span class="number">16</span>($<span class="built_in">t0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h4><p>取错指令</p>
<ol>
<li>阻塞</li>
<li>分支预测</li>
</ol>
<p>静态预测</p>
<p>动态预测</p>
<p>当预测错误时，流水线控制必须确保被错误预测的分支后面的指令执行不会生效，并且在正确的分支地址处重新开始启动流水线。</p>
<h3 id="流水线数据通路"><a href="#流水线数据通路" class="headerlink" title="流水线数据通路"></a>流水线数据通路</h3><h4 id="流水线寄存器"><a href="#流水线寄存器" class="headerlink" title="流水线寄存器"></a>流水线寄存器</h4><p>IF/ID，ID/EX，EX/MEM，MEM/WB</p>
<p><img src="//yoursite.com/2019/06/10/计组复习笔记（三）/blog\source\_posts\sql\12.PNG" alt="12"></p>
<h4 id="最终的数据通路与控制"><a href="#最终的数据通路与控制" class="headerlink" title="最终的数据通路与控制"></a>最终的数据通路与控制</h4><p><img src="//yoursite.com/2019/06/10/计组复习笔记（三）/blog\source\_posts\sql\13.PNG" alt="13"></p>
<h3 id="数据冒险：旁路与阻塞"><a href="#数据冒险：旁路与阻塞" class="headerlink" title="数据冒险：旁路与阻塞"></a>数据冒险：旁路与阻塞</h3><h4 id="冒险条件"><a href="#冒险条件" class="headerlink" title="冒险条件"></a>冒险条件</h4><p>前提：写操作(EX/MEM.RegWrite, MEM/WB.RegWrite有效)，写目的寄存器不能是$zero</p>
<p>1a. EX/MEM.RegisterRd = ID/EX.RegisterRs≠ 0    ForwardA = 10</p>
<p>1b. EX/MEM.RegisterRd = ID/EX.RegisterRt≠ 0    ForwardB = 10</p>
<p>2a. MEM/WB.RegisterRd = ID/EX.RegisterRs≠ 0    ForwardA = 01</p>
<p>2b. MEM/WB.RegisterRd = ID/EX.RegisterRt≠ 0    ForwardB = 01</p>
<p>1—Fwd from EX/MEM pipeline reg</p>
<p>2—Fwd from MEM/WB pipeline reg</p>
<p>ForwardA=0：第一个ALU操作数来自寄存器，ForwardB同理</p>
<h4 id="旁路单元"><a href="#旁路单元" class="headerlink" title="旁路单元"></a>旁路单元</h4><p><img src="//yoursite.com/2019/06/10/计组复习笔记（三）/blog\source\_posts\sql\14.PNG" alt="14"></p>
<p>01选通MEM/WB；10选通EX/MEM</p>
<p>==为什么有两个Rt啊？还有下面加的红色语句我也没有理解目的所在==</p>
<p>更复杂的潜在数据冒险：比如一个寄存器对多个数字进行求和运算，一系列连续的指令将会读写到同一寄存器：</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add </span>$<span class="number">1</span>,$<span class="number">1</span>,$<span class="number">2</span></span><br><span class="line"><span class="keyword">add </span>$<span class="number">1</span>,$<span class="number">1</span>,$<span class="number">3</span></span><br><span class="line"><span class="keyword">add </span>$<span class="number">1</span>,$<span class="number">1</span>,$<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>第二条指令的EX/MEM数据才是最新的。因此，改变MEM冒险的控制策略：</p>
<p><strong>MEM hazard</strong></p>
<p>if (MEM/WB.RegWrite and (MEM/WB.RegisterRd ≠ 0)<br>​     <font color="red">and not (EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0)</font><br>​                   <font color="red">and (EX/MEM.RegisterRd = ID/EX.RegisterRs))</font><br>​     and (MEM/WB.RegisterRd = ID/EX.RegisterRs))<br>   ForwardA = 01</p>
<p>if (MEM/WB.RegWrite and (MEM/WB.RegisterRd ≠ 0)<br>​      <font color="red">and not (EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0)</font><br>​                  <font color="red"> and (EX/MEM.RegisterRd = ID/EX.RegisterRt))</font><br>​     and (MEM/WB.RegisterRd = ID/EX.RegisterRt))<br>   ForwardB = 01</p>
<h4 id="Load-Use冒险检测单元"><a href="#Load-Use冒险检测单元" class="headerlink" title="Load-Use冒险检测单元"></a>Load-Use冒险检测单元</h4><p>工作在ID级，从而可以在装载指令与紧随其后需要它的结果的指令间插入阻塞</p>
<p>阻塞条件：ID/EX.MemRead and   ((ID/EX.RegisterRt = IF/ID.RegisterRs) or    (ID/EX.RegisterRt = IF/ID.RegisterRt))</p>
<p>插入空指令：把ID/EX流水线寄存器的EX、MEM、WB级的控制信号都置为0.仍向前传递，但控制信号为0不会进行Reg和MEM的写操作。（事实上只需将RegWrite和MenWrite置为0）</p>
<p><img src="//yoursite.com/2019/06/10/计组复习笔记（三）/blog\source\_posts\sql\15.PNG" alt="15"></p>
<p><strong>通路</strong></p>
<p><img src="//yoursite.com/2019/06/10/计组复习笔记（三）/blog\source\_posts\sql\16.PNG" alt="16"></p>
<p>冒险检测控制单元控制PC和IF/ID流水线寄存器的写入，以及在实际控制信号与全0中进行选择的多选器。若冒险条件为真，阻塞并清除所有控制字段。</p>
<h3 id="控制冒险-1"><a href="#控制冒险-1" class="headerlink" title="控制冒险"></a>控制冒险</h3><p>增加寄存器比较电路，如果参与比较的两个寄存器，是两步之前的ALU结果，可以通过旁路解决冒险。如果参与比较的两个寄存器其中有一个，是前一步的ALU结果或是两步之前load的结果，需要一个阻塞。如果参与比较的两个寄存器其中有一个，是前一步的load的结果，需要两个阻塞。</p>
<h4 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h4><p>分支预测缓存Branch prediction buffer (aka branch history table)：一小块按照分支指令的低位地址索引的存储器区，其中包括一位或多位数据用以说明最近是否发生过分支。</p>
<p>2位预测位</p>
<p><img src="//yoursite.com/2019/06/10/计组复习笔记（三）/blog\source\_posts\sql\17.PNG" alt="17"></p>
<p>依然需要花费一个时钟周期的开销，去计算分支目标地址。使用延迟分支或分支目标地址缓存</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>（另一种形式的控制冒险，机制相同，不同的是由异常重置控制信号）</p>
<p>异常程序计数器EPC：保存出错指令的地址+4</p>
<p>协处理器CP0</p>
<p>Jump to handler at 8000 00180</p>
<p>记录引起异常的原因的两种方法</p>
<ol>
<li>Cause寄存器：有一个字段记录引起异常的原因</li>
<li>向量中断，控制权转移到由异常原因决定的地址处</li>
</ol>
<p><img src="//yoursite.com/2019/06/10/计组复习笔记（三）/blog\source\_posts\sql\18.PNG" alt="18"></p>
<font color="red">从MEM/WB寄存器WB部分出来的向上向左的那个信号，有点小错误，应该只向Registers，是一个写寄存器的控制信号。</font>

<p>多重中断，硬件对异常进行排序从而使得最先发生异常的指令被中断。优先级最高的异常处理完后，继续处理后面的异常。</p>
<p>非精确中断/非精确异常：在流水线中，将每一个异常与导致该异常的指令对应起来难度很大，EPC中放入相近的值，由操作系统确定精确位置。精确异常是为了支持虚拟存储器。</p>
<h3 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h3><p>增加流水线的指令级并行程度：</p>
<ol>
<li>增加流水线的深度—-更多的重叠</li>
<li>复制计算机内部部件的数量—每个流水既可以启动多条指令—-多发射multiple issue</li>
</ol>
<h4 id="多发射"><a href="#多发射" class="headerlink" title="多发射"></a>多发射</h4><p>CPI可能小于1，可使用IPC</p>
<p>静态多发射（在编译时）</p>
<p>动态多发射（在执行时）</p>
<p>发射槽 issue slot</p>
<p>Speculation 推测：编译器或处理器推测指令结果以消除其他指令对该结果的依赖。</p>
<p>推测错误时需要回卷。    指令重排、缓存结果</p>
<h4 id="静态多发射处理器"><a href="#静态多发射处理器" class="headerlink" title="静态多发射处理器"></a>静态多发射处理器</h4><p>使用编译器封装指令并处理冒险，若无可同时发射的，用nop代替</p>
<p>发射包 issue packet：在一个时空周期内发射的多条指令的集合。可有编译器静态生成或处理器动态生成。对一个周期内能发射的多条指令有所限制。</p>
<p>超长指令字VLIW</p>
<p>例：Two-issue packets</p>
<p>One ALU/branch instruction</p>
<p>One load/store instruction</p>
<p> <strong>数据通路</strong></p>
<p><img src="//yoursite.com/2019/06/10/计组复习笔记（三）/blog\source\_posts\sql\19.PNG" alt="19"></p>
<p>数据冒险：</p>
<p>EX数据：同一个包中，can’t use ALU result in load/store</p>
<p>load-use：会增加延迟</p>
<p><strong>调度</strong></p>
<p>Loop: lw   \$t0,0(\$s1)      # \$t0=array element<br>​      addu \$t0, \$t0,\$s2    # add scalar in \$s2<br>​      sw   \$t0,0(\$s1)      # store result<br>​      addi \$s1,\$s1,–4      # decrement pointer<br>​      bne  \$s1,\$zero, Loop # branch $s1!=0</p>
<table>
<thead>
<tr>
<th></th>
<th>ALU/branch</th>
<th>Load/store</th>
<th>cycle</th>
</tr>
</thead>
<tbody>
<tr>
<td>Loop:</td>
<td>nop</td>
<td>lw   t0, 0($s1)</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>addi   s1,   $s1,–4</td>
<td>nop</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>addu   t0,   $t0, $s2</td>
<td>nop</td>
<td>3</td>
</tr>
<tr>
<td></td>
<td>bne  s1,   $zero, Loop</td>
<td>sw   \$t0,   4($s1)</td>
<td>4</td>
</tr>
</tbody>
</table>
<p> 循环展开（循环体复制4份）：</p>
<table>
<thead>
<tr>
<th></th>
<th>ALU/branch</th>
<th>Load/store</th>
<th>cycle</th>
</tr>
</thead>
<tbody>
<tr>
<td>Loop:</td>
<td>addi   s1,   $s1,–16</td>
<td>lw   \$t0, 0($s1)</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>nop</td>
<td>lw   t1, 12($s1)</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>addu   t0,   t0, $s2</td>
<td>lw   \$t2, 8($s1)</td>
<td>3</td>
</tr>
<tr>
<td></td>
<td>addu   t1,   t1, $s2</td>
<td>lw   \$t3, 4($s1)</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>addu   t2,   t2, $s2</td>
<td>sw   \$t0,   <font color="red">16</font>($s1)</td>
<td>5</td>
</tr>
<tr>
<td></td>
<td>addu   t3,   t4, $s2</td>
<td>sw   \$t1,   12($s1)</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td>nop</td>
<td>sw   t2,   8($s1)</td>
<td>7</td>
</tr>
<tr>
<td></td>
<td>bne  s1,   $zero, Loop</td>
<td>sw   \$t3,   4($s1)</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>寄存器重命名——引入临时寄存器，消除虚假的数据依赖（反相关）</p>
<font color="red">标红处是16而不是0，是因为第一行\$t0取的是\$s1未减去16处的值，从第二行开始，通过旁路技术，$s1已减去16</font>

<h4 id="动态多发射处理器"><a href="#动态多发射处理器" class="headerlink" title="动态多发射处理器"></a>动态多发射处理器</h4><p>也叫超标量处理器</p>
<p>指令顺序发射，乱序执行，顺序提交。处理器决定每个周期几条指令，硬件保证正确性。</p>
<p>流水线被划分为：取指与发射单元、多个功能单元、一个提交单元（含重排序缓冲区）。每个功能单元有自己的缓冲区（保留站）用于保存操作数和操作。</p>
<p><img src="//yoursite.com/2019/06/10/计组复习笔记（三）/blog\source\_posts\sql\20.PNG" alt="20"></p>
<p><strong>寄存器重命名</strong></p>
<p>保留站和重排序缓冲区提供寄存器重命名机制。发射指令时，它先被复制到合适的功能单元的保留站。如果操作数在寄存器堆中或重排序缓冲区中可用，那么立即数被复制到保留站中。否则该指令一直缓存在保留站中。若指令已发射，那么操作数对应的寄存器的值可以被覆盖。如果操作数不在寄存器堆中或重排序缓冲区中，那么他应该是某个功能单元的结果，硬件帮助定位该功能单元，计算出结果时直接从功能单元复制到保留站，跳过寄存器堆。</p>
<h5 id="推测"><a href="#推测" class="headerlink" title="推测"></a>推测</h5><p><strong>Predict branch and continue issuing</strong></p>
<p>Don’t commit until branch outcome determined</p>
<p><strong>Load speculation</strong></p>
<p>Avoid load and cache miss delay</p>
<ol>
<li>Predict the effective address</li>
<li>Predict loaded value</li>
<li>Load before completing outstanding stores</li>
<li>Bypass stored values to load unit</li>
</ol>
<p>Don’t commit load until speculation cleared</p>
<p><strong>为什么需要动态调度？</strong></p>
<ol>
<li>并不是所有的阻塞都可以预知。动态调度在一些指令阻塞时调度其他指令，以掩盖阻塞。</li>
<li>对于分支指令，若采用动态推测而不是用动态调度，会极大限制指令级并行度。</li>
<li>流水线延迟和发射宽度根据处理器的具体实现的不同有很大差别。</li>
</ol>
<p>多发射的阻碍：窗口期有限、内存访问延迟、带宽受限</p>
<p>动态调度和推测消耗能源</p>
<p>指令集、数据通路和控制的设计之间相互影响</p>
<hr>
<font color="green"><a href="http://landcareweb.com/questions/43313/tui-ce-he-yu-ce-zhi-jian-de-chai-yi" target="_blank" rel="noopener">预测和推测之间有什么区别？</a></font>

<p>分支预测由处理器完成，以试图确定在条件跳转之后执行将继续的位置，以便它可以从存储器读取下一条指令。</p>
<p>推测执行更进一步，并确定执行下一条指令的结果。如果分支预测是正确的，则使用结果，否则将其丢弃。即使代码中没有实际的条件分支，也可以应用推测执行。处理器可以从通常将连续执行的若干指令确定结果，但是可以例如通过算术溢出中断来停止执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/10/计组复习笔记（二）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="Joyce">
      <meta itemprop="description" content="Growing Path">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joyce' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/10/计组复习笔记（二）/" class="post-title-link" itemprop="url">计组复习笔记（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-06-10 16:08:24 / 修改时间：19:31:43" itemprop="dateCreated datePublished" datetime="2019-06-10T16:08:24+08:00">2019-06-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机的算术运算"><a href="#计算机的算术运算" class="headerlink" title="计算机的算术运算"></a>计算机的算术运算</h2><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>高位HI，低位LO</p>
<p>Instructions</p>
<p>mult rs, rt  /  multu rs, rt    64-bit product in HI/LO</p>
<p>mfhi rd  /  mflo rd    Move from HI/LO to rd，Can test HI value to see if product overflows 32 bits</p>
<p>mul rd, rs, rt    Least-significant 32 bits of product –&gt; rd</p>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><h4 id="数值表示"><a href="#数值表示" class="headerlink" title="数值表示"></a>数值表示</h4><font color="red">尾数精度=尾数位数+1</font>

<p>单精度规格化数：阶码取值范围在1~254之间；尾数可以取任何值。</p>
<p>对于float型，特殊的值：</p>
<table>
<thead>
<tr>
<th>符号位</th>
<th>阶码/指数</th>
<th>尾数</th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>+/-</td>
<td>全0</td>
<td>全0</td>
<td>0</td>
</tr>
<tr>
<td>+/-</td>
<td>全1(=255)</td>
<td>全0</td>
<td>+无穷/-无穷</td>
</tr>
<tr>
<td>+/-</td>
<td>全0</td>
<td>非0</td>
<td>非规格化数</td>
</tr>
<tr>
<td>+/-</td>
<td>全1(=255)</td>
<td>非0</td>
<td>非数NaN</td>
</tr>
</tbody>
</table>
<p>移码</p>
<p>精度范围</p>
<p>高级语言中可以定义多种数据类型，因此需要存取不同长度操作数的数据传输指令。</p>
<p>对阶的时候，需要小阶向大阶看齐，因为大阶如果向小阶看齐，那么就要左移，不符号规格化的要求。</p>
<p>浮点数乘法运算结果规格化：不需要左移，最多需要一次右移；除法：不需要右移，最多需要一次左移。正常的运算过程下，若尾数为0，则结果的阶码也置为0.</p>
<p>浮点加法不满足结合律</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/08/数据库复习笔记（四）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="Joyce">
      <meta itemprop="description" content="Growing Path">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joyce' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/08/数据库复习笔记（四）/" class="post-title-link" itemprop="url">数据库复习笔记（四）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-08 15:23:44" itemprop="dateCreated datePublished" datetime="2019-06-08T15:23:44+08:00">2019-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-06-14 09:41:17" itemprop="dateModified" datetime="2019-06-14T09:41:17+08:00">2019-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><p>parse - convert（Parse Tree -&gt; Logical Query Plan） - apply laws（Improving the L.Q.P） - estimate result sizes - consider physical plans - estimate costs - pick best - execute</p>
<p>选择和投影尽量早做</p>
<font color="red">后面整个么懂——反正考试不做要求</font>

<p>Parameters for Estimation</p>
<p>M: # of available main memory buffers (estimate) </p>
<p>Kept as statistics for each relation R:</p>
<p>–T(R) : # of tuples in R</p>
<p>–B(R): # of blocks to hold all tuples of R</p>
<p>–V(R, A): # of distinct values for attribute R.A</p>
<p>  = SELECT COUNT (DISTINCT A) FROM R  </p>
<p>•Physical operators </p>
<p>–to implement physical query plans</p>
<p>–selections, joins</p>
<p>–one-pass, two-pass, (multi-pass)</p>
<p>–based on scanning, sorting, hashing, existing indexes</p>
<h2 id="Crash-Recovery"><a href="#Crash-Recovery" class="headerlink" title="Crash Recovery"></a>Crash Recovery</h2><h3 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h3><p>从后向前恢复</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>Consider a system that uses pure undo logging. After a system crash, we find the following log entries on disk:</p>
<p>\<start t1="">;&lt;T1,A,5&gt;;\<start t2="">, &lt;T1,B,1&gt;; \<commit t1="">;&lt;T2,B,11&gt;,&lt;T2,C,8&gt;,\<commit t2="">; \<start t3="">;&lt;T3,A,10&gt;;\<start t4="">; &lt;T4,A,11&gt;, &lt;T3,C,7&gt;;&lt;T4,B,22&gt;</start></start></commit></commit></start></start></p>
<p>The last four actions in the schedule were incrementing each object by 1(e.g.&lt;T4,A,11&gt; was updating A to 12). How many different combinations of values of values for A,B,and C could possibly exist on disk at the time of the system crash?</p>
<font color="red">A: 10,11,12；B: 22,23；C: 7,8。共12种可能</font>

<font color="green"> &lt;T4,A,11&gt;的只能体现，此时内存中的A被T3改成了11，但是磁盘上有没有被T3改过呢？不知道。内存中写了&lt;Ti, X, v&gt;，才可以改内存中的数据，所有&lt;Ti, X, v&gt;flush之后，才可以改磁盘数据。</font>

<h3 id="Redo日志"><a href="#Redo日志" class="headerlink" title="Redo日志"></a>Redo日志</h3><p>从前向后恢复</p>
<p>恢复速度极慢 -&gt; 静态检查点</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>Consider a system that uses pure redo logging. The initial database state was A=0,B=1,C=2. After a system crash, we find the following log entries on disk:</p>
<p>\<start t1="">,&lt;T1,A,5&gt;,\<start t2="">, &lt;T1,B,1&gt;, \<commit t1="">,&lt;T2,B,11&gt;,&lt;T2,C,8&gt;,\<commit t2="">, \<ckpt>,\<start t3="">,&lt;T3,A,10&gt;,\<start t4="">, &lt;T4,A,11&gt;, &lt;T3,C,7&gt;, &lt;T4,B,22&gt;</start></start></ckpt></commit></commit></start></start></p>
<p>How many different combinations of values for A,B, and C could possibly exist on disk at the time of the system crash?</p>
<p>A: 5；B: 11；C: 8。有一种可能</p>
<h3 id="Undo-redo日志"><a href="#Undo-redo日志" class="headerlink" title="Undo/redo日志"></a>Undo/redo日志</h3><p>&lt;Ti, X, Old-X-value, New-X-value&gt;</p>
<p>恢复时，从前向后redo完成(有commit)的，从后向前undo未完成的</p>
<h4 id="动态检查点"><a href="#动态检查点" class="headerlink" title="动态检查点"></a>动态检查点</h4><start ckpt="" ti,t2,…(未完成的事务undo)="">

<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p>Consider a system that uses undo-redo logging. After a system crash, we find the following log entries on disk:</p>
<p>\<start t1="">&lt;T1,A,5,0&gt;\<start t2="">&lt;T1,B,1,2&gt;\<commit t1="">&lt;T2,B,2,3&gt;</commit></start></start></p>
<p><start ckpt(t2)="">&lt;T2,C,8,9&gt;\<commit t2="">\<end ckpt=""></end></commit></start></p>
<p>\<start t3="">&lt;T3,A,0,10&gt;\<start t4="">&lt;T4,A,10,11&gt;&lt;T3,C,9,7&gt;&lt;T4,B,3,22&gt;</start></start></p>
<p>How many different combinations of values for A,B, and C could possibly exist on disk at the time of the system crash?</p>
<p>A: 0,10,11；B: 3,22；C: 8,9,7</p>
<p>共18种可能</p>
<p>undo: T3,T4；redo: T2</p>
<p>结果：0,3,9</p>
<h2 id="Concurrency-Control"><a href="#Concurrency-Control" class="headerlink" title="Concurrency Control"></a>Concurrency Control</h2><p>优先图</p>
<h3 id="可串行调度"><a href="#可串行调度" class="headerlink" title="可串行调度"></a>可串行调度</h3><h4 id="乐观方法"><a href="#乐观方法" class="headerlink" title="乐观方法"></a>乐观方法</h4><h4 id="悲观方法"><a href="#悲观方法" class="headerlink" title="悲观方法"></a>悲观方法</h4><p>两段锁协议</p>
<p>共享锁：</p>
<p>写读后写的元素，可以直接上写锁，或者先上读锁，写的时候再升级为写锁；提倡第二种。</p>
<p>更新锁：解决两个事务对同一元素上了读锁，形成死锁的问题。If Ti wants to read A and knows it</p>
<p>may later want to write A, it requests an update lock (not shared)</p>
<h3 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h3><p>一次封锁法：对所有要用的数据都加锁</p>
<h4 id="顺序封锁法"><a href="#顺序封锁法" class="headerlink" title="顺序封锁法"></a>顺序封锁法</h4><p>调度器1负责按照rule1，rule3给事务加锁；调度器2负责按照rule2形成调度。</p>
<h4 id="意向锁-IX，IS"><a href="#意向锁-IX，IS" class="headerlink" title="意向锁 IX，IS"></a>意向锁 IX，IS</h4><p>插入时需锁父表，上Lx；删除时上Lx</p>
<h4 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h4><table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody>
<tr>
<td>IS</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>F</td>
</tr>
<tr>
<td>IX</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>S</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>F</td>
</tr>
<tr>
<td>X</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>S</th>
<th>X</th>
<th>U</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>T</td>
<td>F</td>
<td>T</td>
</tr>
<tr>
<td>X</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>U</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Parent  Child locked in</th>
<th>Child can be locked in</th>
</tr>
</thead>
<tbody>
<tr>
<td>IS</td>
<td>IS,S</td>
</tr>
<tr>
<td>IX</td>
<td>IS,S,IX,X</td>
</tr>
<tr>
<td>S</td>
<td>[S,IS; not necessary]</td>
</tr>
<tr>
<td>X</td>
<td>NONE</td>
</tr>
</tbody>
</table>
<h4 id="事务的特性（ACID"><a href="#事务的特性（ACID" class="headerlink" title="事务的特性（ACID)"></a>事务的特性（ACID)</h4><p>•原子性（Atomicity）</p>
<p>•一致性（Consistency）</p>
<p>•隔离性（Isolation）</p>
<p>•持续性（Durability）</p>
</start>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/07/201812CET6_3Comp/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="Joyce">
      <meta itemprop="description" content="Growing Path">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joyce' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/07/201812CET6_3Comp/" class="post-title-link" itemprop="url">201812CET6_3Comp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-07 10:56:39" itemprop="dateCreated datePublished" datetime="2019-06-07T10:56:39+08:00">2019-06-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="How-to-balance-job-responsibilities-and-personal-interests"><a href="#How-to-balance-job-responsibilities-and-personal-interests" class="headerlink" title="How to balance job responsibilities and personal interests"></a>How to balance job responsibilities and personal interests</h3><font color="red">「personal interests」指「个人兴趣」还是「个人利益」？</font>

<p>我觉得出题人没必要在这种词上面作妖，两种解释都有道理，而根据两外两个题：extracurriculer和leisure，此处应该是爱好的意思。</p>
<font color="blue">Along with the development of society</font>， more and more problems <font color="blue">are brought to our attention</font>； one of the most serious problems is how to <font color="blue">reach the balance between</font> job responsibilities and personal interests. People have different <font color="blue">attitudes towards </font>the problem.<br><br><font color="blue">It is generally agreed that job responsibilities has been playing an increasingly important role in our life</font>， because we need to complete them to earn money for life. But if people put too much time on work， their<font color="blue"> mental conditions will be damaged and suffer from kinds of diseases</font>. The<font color="blue"> sub health</font> of workers has <font color="blue">attracted extensive attention</font> of the society， which can be found in TV programs， newspapers， university classes and many aspect of our everyday life. Thus， in addition to work responsibility， people should develop personal interests using spare time. Then， they could enjoy the life and get rest <font color="blue">both physically and mentally</font>. However， if people invest too much time on personal interests， their career developments may be affected and lost opportunities for a better life.<br><br>From what has been discussed above， we may<font color="blue"> safely draw the conclusions </font>that people should focus on work responsibility during work time and develop personal interests on spare time.<br><br>———-<br><br>Recently, the topic of hobby has been<font color="blue"> brought to public attention</font>. We can find many examples easily: modern people‘ s <font color="blue">workload </font>makes people <font color="blue">out of breath </font>and<font color="blue"> leaves them no time for their interest. </font>

<p>If this situation <font color="blue">continues to worsen</font>, their physical and mental status <font color="blue">raises the alarm</font>. Thus, it’s <font color="blue">urgent</font> to<font color="blue"> strike a good balance between working duties and personal hobbies</font>. For one thing, too much work<font color="blue"> gives rise to immunity deterioration</font>, which causes many health problems. For another, <font color="blue">constructive pastime</font> helps us <font color="blue">live in a positive cycle.</font></p>
<p>Therefore, what we should do is to find enough time to develop our hobbies<font color="blue"> by finishing the task on time </font>and arranging some beneficial activities <font color="blue">off work</font>. For example, regular exercise is<font color="blue"> a commendable way </font>to get relaxed. By doing exercises your body can<font color="blue"> produce a hormone</font> that makes you <font color="blue">recover from exhaustion</font>. What’s more you can<font color="blue"> transfer your focus from busy job by</font> reading an interesting book or listening to a favorite song,<font color="blue"> thereby getting your intense nerves calm down.</font></p>
<h4 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h4><p>workload n. (某一人或组织的)工作量，工作负担</p>
<p>immunity n. 免疫力;受保护;豁免;免除</p>
<p>deterioration n. 恶化，变坏；退化；堕落</p>
<p>commendable adj. 值得赞扬(或嘉许)的</p>
<p>hormone n. 激素;荷尔蒙</p>
<p>thereby adv. 因此;由此;从而</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/06/算法复习笔记（五）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.jpg">
      <meta itemprop="name" content="Joyce">
      <meta itemprop="description" content="Growing Path">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joyce' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/06/算法复习笔记（五）/" class="post-title-link" itemprop="url">算法复习笔记（五）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-06 23:07:14" itemprop="dateCreated datePublished" datetime="2019-06-06T23:07:14+08:00">2019-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-06-07 19:42:32" itemprop="dateModified" datetime="2019-06-07T19:42:32+08:00">2019-06-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="最大流问题"><a href="#最大流问题" class="headerlink" title="最大流问题"></a>最大流问题</h3><p>容量、源点、汇点、流；流f满足容量条件和守恒定理</p>
<p>在边上用剩余的容量向前推（前向边，c(e)-f(e)）， 并且在已经有流的边上向后推（后向边，f(e)，可撤销的容量）， 使它转向一个不同的方向。 </p>
<p>剩余图:  $G_f$= (V, $E_f$). 具有正的剩余容量的剩余边。$ E_f$= {e} ∪{$e^R$}.</p>
<p>令P是$G_f$中一条简单的s-t路径（增广路径）。bottleneck(P,f)是P上任何边关于流f的最小剩余容量。算法augment(f,P)在G中产生一 个新的流f’.不断调整Gf来获取更大的流量.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Augment(f, P) &#123; </span><br><span class="line">    b ←bottleneck(P) </span><br><span class="line">    foreach e ∈P &#123; <span class="comment">//宽度优先或者广度优先搜索，代价为 O(m+n)=O(m); </span></span><br><span class="line">        <span class="keyword">if</span>(e ∈E) f(e) ←f(e) + b </span><br><span class="line">        <span class="keyword">else</span> f(eR) ←f(e) -b &#125; </span><br><span class="line">    <span class="keyword">return</span> f &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ford-Fulkerson(G,s,t,c)&#123;</span><br><span class="line">    foreach e ∈E f(e)←0</span><br><span class="line">    Gf ← residual graph</span><br><span class="line">    <span class="keyword">while</span>(there exists augmenting path P)&#123;</span><br><span class="line">        f ← Augment(f,c,P)</span><br><span class="line">        update Gf</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ford-Fulkerson算法可以在 O(mC)时间内实现</p>
<h4 id="最大流与最小割"><a href="#最大流与最小割" class="headerlink" title="最大流与最小割"></a>最大流与最小割</h4><p>v(f)≤c(A,B)，每个流的值是以每个割的容量为上界的。证明：流f的值=A的出度-A的入度≤A的出度=割(A,B)的容量</p>
<p>最大流的值等于最小割</p>
<h4 id="选择好的增广路径"><a href="#选择好的增广路径" class="headerlink" title="选择好的增广路径"></a>选择好的增广路径</h4><p>选择了一条瓶颈容量很小的增广路径， 导致收敛很慢！— 选择具有大的瓶颈容量的路径，进展会更大些</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Scaling-Max-Flow(G, s, t, c) &#123; </span><br><span class="line">    foreach e ∈E  f(e) ←0 </span><br><span class="line">    ∆←largest power of <span class="number">2</span> &lt;= Max of Ce out of s </span><br><span class="line">    Gf←residual graph</span><br><span class="line">	<span class="keyword">while</span>(∆≥<span class="number">1</span>) &#123; <span class="comment">// 外层While循环的迭代次数至多是 1 + ⎡log2 C⎤ </span></span><br><span class="line">        Gf(∆)←∆-residual graph </span><br><span class="line">        <span class="keyword">while</span>(there exists augmenting path P in Gf(∆)) &#123; </span><br><span class="line">            <span class="comment">//在∆缩放阶段，每次增广增加的流值至少是∆.</span></span><br><span class="line">            <span class="comment">//在一个缩放阶段增广次数至多是2m</span></span><br><span class="line">            f ←augment(f, c, P) <span class="comment">//一次增广用O(m)时间(包括建立图，找到合适路径)</span></span><br><span class="line">            update Gf(∆) </span><br><span class="line">        &#125; </span><br><span class="line">        ∆←∆/ <span class="number">2</span> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分匹配问题"><a href="#二分匹配问题" class="headerlink" title="二分匹配问题"></a>二分匹配问题</h3><h4 id="构造最大流"><a href="#构造最大流" class="headerlink" title="构造最大流"></a>构造最大流</h4><p>构造图G’ = (L ∪R∪{s, t},  E’ ). 连接原图L到R的每条边, 每条边赋予单位容 量；增加一个源点s, 从s到L中的每个结点连接一 条边，每条边赋予单位容量；增加一个终点t, 从R中的每个结点到t连接一 条边，每条边赋予单位容量。</p>
<p> G中最大匹配的数目与所定义的G‘中最大流值相同. </p>
<p>令n=|L|=|R|,m是G的边数，一般假定初始问题中每个结点至少存在一条关联边， 因此m&gt;=n/2. </p>
<p>时间复杂度：C=|L|=n,根据以前O(mC)的界——Ford-Fulkerson算法在 O(mn)时间内找到二部图中的一个最大匹配</p>
<h2 id="NP与计算的难解性"><a href="#NP与计算的难解性" class="headerlink" title="NP与计算的难解性"></a>NP与计算的难解性</h2><table>
<thead>
<tr>
<th>贪心算法</th>
<th>区间调度</th>
<th>O(nlogn)</th>
</tr>
</thead>
<tbody>
<tr>
<td>分治策略</td>
<td>FFT</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>动态规划</td>
<td>编辑距离</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table>
<h3 id="多项式时间规约"><a href="#多项式时间规约" class="headerlink" title="多项式时间规约"></a>多项式时间规约</h3><p>如果对于问题Y：能用多项式个标准的计算步骤，加上多项式次调用解问题X的黑盒子来解问题Y，则：Y多项式时间可归约到X，或X至少想Y一样难（相对于多项式时间）</p>
<p>$Y≤_pX$ （有传递性）</p>
<p>如果X能在多项式时间内求解，则Y也能在多项式时间内求解；如果Y能在多项式时间内求解，则X也能在多项式时间内求解。</p>
<h4 id="独立集问题"><a href="#独立集问题" class="headerlink" title="独立集问题"></a>独立集问题</h4><p>G=(V,E)，G包含大小至少为k的独立集吗？G包含大小至多为k的顶点覆盖吗？</p>
<p>S是一个独立集当且仅当它的补图V-S是一个顶点覆盖。</p>
<p><strong>集合覆盖</strong>：比顶点覆盖更具一般性，顶点覆盖$≤_p$集合覆盖</p>
<p><strong>使用零件归约</strong></p>
<p>合取范式，可满足性问题SAT，3-SAT：三元可满足性</p>
<p>3-SAT$≤_p$独立集</p>
<p>构造：连接一个三角形的三个顶点（需要同时考虑三个三角形，从三个三角形中各取一个点），并把每个项与它的否定项连接起来。</p>
<p>3-SAT$≤_p$独立集$≤_p$顶点覆盖$≤_p$集合覆盖</p>
<p>寻找问题$≤_p$判别问题</p>
<h3 id="有效证书和NP的定义"><a href="#有效证书和NP的定义" class="headerlink" title="有效证书和NP的定义"></a>有效证书和NP的定义</h3><p>对于判定问题： A解问题X</p>
<p>存在多项式时间解法的问题的集合P</p>
<p>判断素性：用2到根号N来判断N是否能被这些数整除，算法的时间复杂度是指数级别的；AKS算法为多项式级别。</p>
<p>证书串t包含s是X的“yes”实例的证据。</p>
<p>存在t使得：|t|≤p(|s|)且B(s,t)=yes，则B是问题X的有效验证程序，t是证书。</p>
<p>NP是所有存在有效验证程序的问题的集合</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a><strong>例</strong></h4><p>独立集问题：</p>
<p>证书：至少有k个顶点的集合；验证程序B：核实这些顶点中的任何两两之间没有边连接。</p>
<h4 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h4><p>电路可满足性</p>
<p>NP问题要么是P，要么是NP完全问题</p>
<p>难问题的部分分类：</p>
<ol>
<li>包装问题：独立集、集合包装</li>
<li>覆盖问题：顶点覆盖、集合覆盖</li>
<li>划分问题：三维匹配、图着色</li>
<li>排序问题：哈密顿图、哈密顿回路、巡回售货员问题</li>
<li>数值问题：子集和，带开放时间和截止时间的调度问题</li>
<li>约束满足问题：SAT，3SAT</li>
</ol>
<p><img src="//yoursite.com/2019/06/06/算法复习笔记（五）/Users\asus\AppData\Roaming\Typora\typora-user-images\1559907526582.png" alt="1559907526582"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Joyce" src="/images/logo.jpg">
  <p class="site-author-name" itemprop="name">Joyce</p>
  <div class="site-description" itemprop="description">Growing Path</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">306</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Joycepy" title="GitHub → https://github.com/Joycepy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/pichunying@gmail.com" title="E-Mail → pichunying@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://tiffanychou21.github.io/" title="https://tiffanychou21.github.io/" rel="noopener" target="_blank">ZCF</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://jybwob.tk/" title="http://jybwob.tk/" rel="noopener" target="_blank">JYB</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://flippedyue.github.io/" title="https://flippedyue.github.io/" rel="noopener" target="_blank">JY</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Joyce</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
